<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Paint Alt - Web</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    *{margin:0;padding:0;box-sizing:border-box;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif}
    body{overflow:hidden;background:#f5f5f7;color:#333}
    .container{display:grid;height:100vh;grid-template-columns:250px 1fr 300px;grid-template-rows:40px 1fr 0px;grid-template-areas:"header header header" "sidebar viewport properties" "timeline timeline timeline";}
    .header{grid-area:header;background:#f8f8f8;border-bottom:1px solid #e1e1e1;display:flex;align-items:center;padding:0 15px}
    .menu{display:flex;gap:20px}
    .menu-item{font-size:13px;cursor:pointer;padding:5px 10px;border-radius:3px;color:#444}
    .menu-item:hover{background:#e9e9e9}
    .sidebar{grid-area:sidebar;background:#f0f0f0;border-right:1px solid #d1d1d1;padding:10px;overflow-y:auto}
    .panel{margin-bottom:15px}
    .panel-header{font-size:12px;text-transform:uppercase;color:#666;padding:5px 0;display:flex;justify-content:space-between;align-items:center}
    .panel-content{padding:5px 0}
    .hierarchy-item{padding:5px 10px;font-size:13px;cursor:pointer;display:flex;align-items:center;gap:5px;border-radius:3px;color:#444}
    .hierarchy-item:hover{background:#e0e0e0}
    .hierarchy-item.active{background:#d0e5ff;color:#0066cc}
    .viewport{grid-area:viewport;position:relative;overflow:hidden;background:#fff;border:1px solid #d1d1d1}
    .viewport-overlay{position:absolute;top:10px;left:10px;color:#333;font-size:12px;background:rgba(255,255,255,.8);padding:5px 10px;border-radius:3px;pointer-events:none;border:1px solid #ddd}
    .viewport-controls{position:absolute;right:10px;top:10px;display:flex;flex-direction:column;gap:5px}
    .viewport-btn{width:30px;height:30px;background:rgba(255,255,255,.9);border:1px solid #ccc;color:#555;border-radius:3px;cursor:pointer;display:flex;align-items:center;justify-content:center}
    .viewport-btn:hover{background:rgba(240,240,240,1)}
    .properties{grid-area:properties;background:#f0f0f0;border-left:1px solid #d1d1d1;padding:15px;overflow-y:auto}
    .property-group{margin-bottom:15px}
    .property-item{margin-bottom:10px}
    .property-label{font-size:12px;color:#666;margin-bottom:5px}
    .property-input{width:100%;background:#fff;border:1px solid #ccc;color:#333;padding:5px 8px;border-radius:3px}
    .property-slider{width:100%}
    .tabs{display:flex;border-bottom:1px solid #d1d1d1;margin-bottom:10px}
    .tab{padding:5px 15px;font-size:12px;cursor:pointer;border-bottom:2px solid transparent;color:#666}
    .tab.active{border-bottom:2px solid #0078d7;color:#0078d7}
    .status-bar{position:fixed;bottom:0;left:0;right:0;height:22px;background:#e1e1e1;display:flex;align-items:center;padding:0 10px;font-size:12px;z-index:1000;color:#555;border-top:1px solid #d1d1d1}
    .toolbar{position:absolute;top:50px;left:10px;display:flex;flex-direction:column;gap:5px;background:rgba(255,255,255,.9);padding:5px;border-radius:3px;border:1px solid #ccc}
    .tool-btn{width:30px;height:30px;display:flex;align-items:center;justify-content:center;cursor:pointer;border-radius:3px;color:#555}
    .tool-btn:hover{background:#e9e9e9}
    .tool-btn.active{background:#d0e5ff;color:#0078d7}
    .timeline{display:none}
    
    /* Canvas styling */
    #paint-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    
    /* Color picker */
    .color-picker {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 10px;
    }
    .color-option {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      cursor: pointer;
      border: 1px solid #ccc;
    }
    .color-option.active {
      border: 2px solid #0078d7;
      box-shadow: 0 0 5px rgba(0,120,215,0.5);
    }
    
    /* Brush preview */
    .brush-preview {
      width: 100%;
      height: 40px;
      background: #fff;
      border-radius: 3px;
      margin-top: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid #ddd;
    }
    .brush-preview-circle {
      border-radius: 50%;
      background: currentColor;
      border: 1px solid rgba(0,0,0,0.2);
    }
    
    /* Custom slider styling */
    input[type="range"] {
      -webkit-appearance: none;
      height: 6px;
      background: #ddd;
      border-radius: 3px;
      outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #0078d7;
      border-radius: 50%;
      cursor: pointer;
    }
    
    /* Checkbox styling */
    input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: #0078d7;
    }
    
    /* Button styling */
    .action-btn {
      background: #0078d7;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      margin-top: 10px;
      width: 100%;
    }
    
    .action-btn:hover {
      background: #106ebe;
    }
    
    .action-btn.secondary {
      background: #f0f0f0;
      color: #333;
      border: 1px solid #ccc;
    }
    
    .action-btn.secondary:hover {
      background: #e0e0e0;
    }
    
    /* Temporary shape preview */
    .temp-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="menu">
        <div class="menu-item"><i class="fas fa-home"></i> Home</div>
        <div class="menu-item"><i class="fas fa-file"></i> File</div>
        <div class="menu-item"><i class="fas fa-edit"></i> Edit</div>
        <div class="menu-item"><i class="fas fa-eye"></i> View</div>
        <div class="menu-item"><i class="fas fa-image"></i> Image</div>
      </div>
    </div>

    <!-- Sidebar -->
    <div class="sidebar">
      <div class="panel">
        <div class="panel-header">
          <span>Tools</span>
        </div>
        <div id="hierarchy" class="panel-content">
          <div class="hierarchy-item active" data-tool="brush"><i class="fas fa-paint-brush"></i><span>Brush</span></div>
          <div class="hierarchy-item" data-tool="eraser"><i class="fas fa-eraser"></i><span>Eraser</span></div>
          <div class="hierarchy-item" data-tool="line"><i class="fas fa-minus"></i><span>Line</span></div>
          <div class="hierarchy-item" data-tool="rectangle"><i class="fas fa-square"></i><span>Rectangle</span></div>
          <div class="hierarchy-item" data-tool="circle"><i class="fas fa-circle"></i><span>Circle</span></div>
          <div class="hierarchy-item" data-tool="fill"><i class="fas fa-fill-drip"></i><span>Fill</span></div>
          <div class="hierarchy-item" data-tool="eyedropper"><i class="fas fa-eye-dropper"></i><span>Eyedropper</span></div>
          <div class="hierarchy-item" data-tool="spray"><i class="fas fa-spray-can"></i><span>Spray Paint</span></div>
          <div class="hierarchy-item" data-tool="text"><i class="fas fa-font"></i><span>Text</span></div>
          <div class="hierarchy-item" data-tool="select"><i class="fas fa-vector-square"></i><span>Select</span></div>
        </div>
      </div>

      <div class="panel">
        <div class="panel-header"><span>Layers</span></div>
        <div class="panel-content">
          <div class="hierarchy-item"><i class="fas fa-eye"></i><span>Background</span></div>
          <div class="hierarchy-item active"><i class="fas fa-eye"></i><span>Layer 1</span></div>
          <div class="hierarchy-item"><i class="fas fa-eye"></i><span>Layer 2</span></div>
          <button class="action-btn secondary" id="add-layer"><i class="fas fa-plus"></i> Add Layer</button>
        </div>
      </div>
    </div>

    <!-- Viewport -->
    <div class="viewport" id="viewport">
      <div class="viewport-overlay">Canvas - 100%</div>
      <canvas id="paint-canvas"></canvas>
      <canvas id="temp-canvas" class="temp-canvas"></canvas>
      <div class="toolbar">
        <div class="tool-btn active" title="Hand Tool"><i class="fas fa-hand-paper"></i></div>
        <div class="tool-btn" title="Zoom Tool"><i class="fas fa-search"></i></div>
        <div class="tool-btn" title="Rotate Canvas"><i class="fas fa-sync"></i></div>
        <div class="tool-btn" title="Fullscreen"><i class="fas fa-expand"></i></div>
      </div>
      <div class="viewport-controls">
        <div class="viewport-btn" id="clear" title="Clear Canvas"><i class="fas fa-trash"></i></div>
        <div class="viewport-btn" id="save" title="Save"><i class="fas fa-save"></i></div>
        <div class="viewport-btn" id="undo" title="Undo"><i class="fas fa-undo"></i></div>
        <div class="viewport-btn" id="redo" title="Redo"><i class="fas fa-redo"></i></div>
      </div>
    </div>

    <!-- Properties -->
    <div class="properties">
      <div class="tabs">
        <div class="tab active">Brush</div>
        <div class="tab">Colors</div>
        <div class="tab">Layers</div>
      </div>

      <div class="property-group">
        <div class="panel-header">Brush Properties</div>
        <div class="property-item">
          <div class="property-label">Size: <span id="brush-size-value">5</span>px</div>
          <input id="prop-brushSize" type="range" class="property-slider" min="1" max="50" value="5" step="1">
        </div>
        <div class="property-item">
          <div class="property-label">Opacity: <span id="opacity-value">100</span>%</div>
          <input id="prop-opacity" type="range" class="property-slider" min="0.1" max="1" value="1" step="0.1">
        </div>
        <div class="property-item">
          <div class="property-label">Hardness: <span id="hardness-value">100</span>%</div>
          <input id="prop-hardness" type="range" class="property-slider" min="0" max="1" value="1" step="0.1">
        </div>
        <div class="property-item">
          <div class="property-label">Smoothing</div>
          <input id="prop-smoothing" type="checkbox" class="property-input" checked>
        </div>
        <div class="property-item">
          <div class="property-label">Brush Preview</div>
          <div class="brush-preview">
            <div id="brush-preview-circle" class="brush-preview-circle"></div>
          </div>
        </div>
      </div>

      <div class="property-group">
        <div class="panel-header">Colors</div>
        <div class="property-item">
          <div class="property-label">Foreground Color</div>
          <input id="prop-color" type="color" class="property-input" value="#ff0000">
        </div>
        <div class="property-item">
          <div class="property-label">Background Color</div>
          <input id="prop-bgColor" type="color" class="property-input" value="#ffffff">
        </div>
        <div class="property-item">
          <div class="property-label">Color Palette</div>
          <div class="color-picker">
            <div class="color-option active" style="background-color: #ff0000;" data-color="#ff0000"></div>
            <div class="color-option" style="background-color: #ff8000;" data-color="#ff8000"></div>
            <div class="color-option" style="background-color: #ffff00;" data-color="#ffff00"></div>
            <div class="color-option" style="background-color: #00ff00;" data-color="#00ff00"></div>
            <div class="color-option" style="background-color: #00ffff;" data-color="#00ffff"></div>
            <div class="color-option" style="background-color: #0000ff;" data-color="#0000ff"></div>
            <div class="color-option" style="background-color: #8000ff;" data-color="#8000ff"></div>
            <div class="color-option" style="background-color: #ff00ff;" data-color="#ff00ff"></div>
            <div class="color-option" style="background-color: #000000;" data-color="#000000"></div>
            <div class="color-option" style="background-color: #404040;" data-color="#404040"></div>
            <div class="color-option" style="background-color: #808080;" data-color="#808080"></div>
            <div class="color-option" style="background-color: #c0c0c0;" data-color="#c0c0c0"></div>
            <div class="color-option" style="background-color: #ffffff;" data-color="#ffffff"></div>
            <div class="color-option" style="background-color: #804000;" data-color="#804000"></div>
            <div class="color-option" style="background-color: #408040;" data-color="#408040"></div>
          </div>
        </div>
      </div>

      <div class="property-group">
        <div class="panel-header">Canvas</div>
        <div class="property-item">
          <div class="property-label">Show Grid</div>
          <input id="prop-grid" type="checkbox" class="property-input">
        </div>
        <div class="property-item">
          <div class="property-label">Paper Texture</div>
          <select id="prop-texture" class="property-input">
            <option value="none">None</option>
            <option value="paper">Paper</option>
            <option value="canvas">Canvas</option>
          </select>
        </div>
        <button class="action-btn" id="new-canvas"><i class="fas fa-file"></i> New Canvas</button>
      </div>
    </div>

    <!-- Timeline (hidden for now) -->
    <div class="timeline"></div>
  </div>

  <div class="status-bar">
    <div style="margin-right:15px;">Ready to draw</div>
    <div id="fps" style="margin-right:15px;">FPS: —</div>
    <div id="cursor">Cursor: (0, 0)</div>
    <div id="canvas-size" style="margin-left:auto;">Canvas: 800 × 600</div>
  </div>

  <script>
    // ---------- Paint App Setup ----------
    const viewport = document.getElementById('viewport');
    const canvas = document.getElementById('paint-canvas');
    const tempCanvas = document.getElementById('temp-canvas');
    const ctx = canvas.getContext('2d');
    const tempCtx = tempCanvas.getContext('2d');

    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));

    // Paint state
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let currentTool = 'brush';
    let currentColor = '#ff0000';
    let brushSize = 5;
    let opacity = 1;
    let hardness = 1;
    let bgColor = '#ffffff';
    let showGrid = false;
    let smoothing = true;
    let canvasHistory = [];
    let historyIndex = -1;
    let smoothPoints = [];
    let shapeStartX = 0;
    let shapeStartY = 0;

    // Initialize canvas
    function resizeCanvas() {
      const oldCanvas = canvas.toDataURL();
      canvas.width = viewport.clientWidth;
      canvas.height = viewport.clientHeight;
      tempCanvas.width = viewport.clientWidth;
      tempCanvas.height = viewport.clientHeight;
      
      // Restore previous content if it exists
      if (canvasHistory.length > 0) {
        const img = new Image();
        img.onload = function() {
          ctx.fillStyle = bgColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
          if (showGrid) drawGrid();
        };
        img.src = oldCanvas;
      } else {
        clearCanvas();
        saveState();
      }
      
      updateCanvasSize();
    }

    function clearCanvas() {
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      if (showGrid) drawGrid();
      updateCanvasSize();
    }

    function drawGrid() {
      ctx.strokeStyle = 'rgba(0,0,0,0.1)';
      ctx.lineWidth = 1;
      
      // Vertical lines
      for (let x = 0; x <= canvas.width; x += 20) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      
      // Horizontal lines
      for (let y = 0; y <= canvas.height; y += 20) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
    }

    // Drawing functions
    function startDrawing(e) {
      isDrawing = true;
      [lastX, lastY] = getMousePos(e);
      shapeStartX = lastX;
      shapeStartY = lastY;
      
      if (currentTool === 'fill') {
        floodFill(lastX, lastY);
        isDrawing = false;
        saveState();
      } else if (currentTool === 'eyedropper') {
        pickColor(lastX, lastY);
        isDrawing = false;
      }
    }

    function draw(e) {
      if (!isDrawing) return;
      
      const [x, y] = getMousePos(e);
      
      // Clear temp canvas for shape preview
      tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
      
      // Handle shape previews
      if (currentTool === 'line' || currentTool === 'rectangle' || currentTool === 'circle') {
        drawShapePreview(shapeStartX, shapeStartY, x, y);
        return;
      }
      
      ctx.globalAlpha = opacity;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      // Smoothing for brush and eraser
      if (smoothing && (currentTool === 'brush' || currentTool === 'eraser')) {
        smoothPoints.push({x, y});
        if (smoothPoints.length > 3) smoothPoints.shift();
        
        if (smoothPoints.length >= 2) {
          const smoothX = smoothPoints.reduce((sum, p) => sum + p.x, 0) / smoothPoints.length;
          const smoothY = smoothPoints.reduce((sum, p) => sum + p.y, 0) / smoothPoints.length;
          
          if (currentTool === 'brush') {
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = brushSize;
            ctx.globalCompositeOperation = 'source-over';
            
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(smoothX, smoothY);
            ctx.stroke();
            
            [lastX, lastY] = [smoothX, smoothY];
          } else if (currentTool === 'eraser') {
            ctx.strokeStyle = bgColor;
            ctx.lineWidth = brushSize;
            ctx.globalCompositeOperation = 'destination-out';
            
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(smoothX, smoothY);
            ctx.stroke();
            
            [lastX, lastY] = [smoothX, smoothY];
          }
        }
        return;
      }
      
      switch(currentTool) {
        case 'brush':
          ctx.strokeStyle = currentColor;
          ctx.lineWidth = brushSize;
          ctx.globalCompositeOperation = 'source-over';
          
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(x, y);
          ctx.stroke();
          break;
          
        case 'eraser':
          ctx.strokeStyle = bgColor;
          ctx.lineWidth = brushSize;
          ctx.globalCompositeOperation = 'destination-out';
          
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(x, y);
          ctx.stroke();
          break;

        case 'spray':
          // Spray paint effect
          ctx.globalCompositeOperation = 'source-over';
          const density = Math.max(5, brushSize);
          for (let i = 0; i < density; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * brushSize;
            const offsetX = Math.cos(angle) * radius;
            const offsetY = Math.sin(angle) * radius;
            
            ctx.fillStyle = currentColor;
            ctx.fillRect(x + offsetX, y + offsetY, 1, 1);
          }
          break;
      }
      
      [lastX, lastY] = [x, y];
    }

    function stopDrawing(e) {
      if (isDrawing) {
        smoothPoints = []; // Clear smooth points
        
        // Handle shape tools on mouse up
        if (currentTool === 'line' || currentTool === 'rectangle' || currentTool === 'circle') {
          const [x, y] = getMousePos(e);
          drawShape(shapeStartX, shapeStartY, x, y);
          tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
        }
        isDrawing = false;
        saveState();
      }
    }

    // Draw shape preview (temporary)
    function drawShapePreview(startX, startY, endX, endY) {
      tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
      tempCtx.globalAlpha = opacity;
      tempCtx.strokeStyle = currentColor;
      tempCtx.lineWidth = brushSize;
      tempCtx.lineCap = 'round';
      tempCtx.lineJoin = 'round';
      tempCtx.setLineDash([5, 5]); // Dashed line for preview

      switch(currentTool) {
        case 'line':
          tempCtx.beginPath();
          tempCtx.moveTo(startX, startY);
          tempCtx.lineTo(endX, endY);
          tempCtx.stroke();
          break;

        case 'rectangle':
          tempCtx.strokeRect(startX, startY, endX - startX, endY - startY);
          break;

        case 'circle':
          const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
          tempCtx.beginPath();
          tempCtx.arc(startX, startY, radius, 0, Math.PI * 2);
          tempCtx.stroke();
          break;
      }
      
      tempCtx.setLineDash([]); // Reset line dash
    }

    // Draw shapes (line, rectangle, circle)
    function drawShape(startX, startY, endX, endY) {
      ctx.globalAlpha = opacity;
      ctx.strokeStyle = currentColor;
      ctx.lineWidth = brushSize;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.globalCompositeOperation = 'source-over';

      switch(currentTool) {
        case 'line':
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(endX, endY);
          ctx.stroke();
          break;

        case 'rectangle':
          ctx.strokeRect(startX, startY, endX - startX, endY - startY);
          break;

        case 'circle':
          const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
          ctx.beginPath();
          ctx.arc(startX, startY, radius, 0, Math.PI * 2);
          ctx.stroke();
          break;
      }
    }

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return [
        e.clientX - rect.left,
        e.clientY - rect.top
      ];
    }

    // Flood fill algorithm
    function floodFill(startX, startY) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const stack = [[startX, startY]];
      const targetColor = getPixelColor(imageData, startX, startY);
      const fillColor = hexToRgb(currentColor);
      
      if (colorsMatch(targetColor, fillColor)) return;
      
      while (stack.length > 0) {
        const [x, y] = stack.pop();
        const index = (y * canvas.width + x) * 4;
        
        if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;
        if (!colorsMatch(getPixelColor(imageData, x, y), targetColor)) continue;
        
        // Set the pixel color
        data[index] = fillColor.r;
        data[index + 1] = fillColor.g;
        data[index + 2] = fillColor.b;
        data[index + 3] = 255;
        
        // Add neighboring pixels to the stack
        stack.push([x + 1, y]);
        stack.push([x - 1, y]);
        stack.push([x, y + 1]);
        stack.push([x, y - 1]);
      }
      
      ctx.putImageData(imageData, 0, 0);
    }

    function getPixelColor(imageData, x, y) {
      const index = (y * imageData.width + x) * 4;
      return {
        r: imageData.data[index],
        g: imageData.data[index + 1],
        b: imageData.data[index + 2],
        a: imageData.data[index + 3]
      };
    }

    function colorsMatch(color1, color2) {
      return color1.r === color2.r && 
             color1.g === color2.g && 
             color1.b === color2.b && 
             color1.a === color2.a;
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : {r: 0, g: 0, b: 0};
    }

    function rgbToHex(r, g, b) {
      return "#" + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      }).join('');
    }

    // Eyedropper tool
    function pickColor(x, y) {
      const imageData = ctx.getImageData(x, y, 1, 1);
      const pixel = imageData.data;
      const color = rgbToHex(pixel[0], pixel[1], pixel[2]);
      
      currentColor = color;
      $('#prop-color').value = color;
      updateBrushPreview();
      
      // Update active color in palette
      $$('.color-option').forEach(option => {
        option.classList.toggle('active', option.dataset.color === color);
      });
      
      // Switch back to brush
      currentTool = 'brush';
      $$('#hierarchy .hierarchy-item').forEach(item => {
        item.classList.toggle('active', item.dataset.tool === 'brush');
      });
    }

    // History functions
    function saveState() {
      // Debounce to prevent excessive saves
      if (saveState.timeout) clearTimeout(saveState.timeout);
      saveState.timeout = setTimeout(() => {
        // Remove any future states if we're not at the end of history
        if (historyIndex < canvasHistory.length - 1) {
          canvasHistory = canvasHistory.slice(0, historyIndex + 1);
        }
        
        // Save current canvas state
        canvasHistory.push(canvas.toDataURL());
        historyIndex++;
        
        // Limit history size
        if (canvasHistory.length > 30) {
          canvasHistory.shift();
          historyIndex--;
        }
      }, 100);
    }

    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        const img = new Image();
        img.onload = function() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
        };
        img.src = canvasHistory[historyIndex];
      }
    }

    function redo() {
      if (historyIndex < canvasHistory.length - 1) {
        historyIndex++;
        const img = new Image();
        img.onload = function() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
        };
        img.src = canvasHistory[historyIndex];
      }
    }

    // Update brush preview
    function updateBrushPreview() {
      const preview = document.getElementById('brush-preview-circle');
      preview.style.width = `${brushSize}px`;
      preview.style.height = `${brushSize}px`;
      preview.style.backgroundColor = currentColor;
      preview.style.opacity = opacity;
    }

    function updateCanvasSize() {
      $('#canvas-size').textContent = `Canvas: ${canvas.width} × ${canvas.height}`;
    }

    // ---------- UI Event Handlers ----------
    // Tool selection
    $$('#hierarchy .hierarchy-item').forEach(el => {
      el.addEventListener('click', () => {
        $$('#hierarchy .hierarchy-item').forEach(item => item.classList.remove('active'));
        el.classList.add('active');
        currentTool = el.dataset.tool;
        
        // Update cursor based on tool
        switch(currentTool) {
          case 'brush':
          case 'eraser':
          case 'spray':
            canvas.style.cursor = 'crosshair';
            break;
          case 'eyedropper':
            canvas.style.cursor = 'cell';
            break;
          case 'line':
          case 'rectangle':
          case 'circle':
            canvas.style.cursor = 'crosshair';
            break;
          default:
            canvas.style.cursor = 'default';
        }
      });
    });

    // Brush properties
    $('#prop-brushSize').addEventListener('input', e => {
      brushSize = parseInt(e.target.value);
      $('#brush-size-value').textContent = brushSize;
      updateBrushPreview();
    });

    $('#prop-opacity').addEventListener('input', e => {
      opacity = parseFloat(e.target.value);
      $('#opacity-value').textContent = Math.round(opacity * 100);
      updateBrushPreview();
    });

    $('#prop-hardness').addEventListener('input', e => {
      hardness = parseFloat(e.target.value);
      $('#hardness-value').textContent = Math.round(hardness * 100);
      // Note: Hardness would affect brush shape in a more advanced implementation
    });

    $('#prop-smoothing').addEventListener('change', e => {
      smoothing = e.target.checked;
    });

    // Color selection
    $('#prop-color').addEventListener('input', e => {
      currentColor = e.target.value;
      updateBrushPreview();
      
      // Update active color in palette
      $$('.color-option').forEach(option => {
        option.classList.toggle('active', option.dataset.color === currentColor);
      });
    });

    // Color palette
    $$('.color-option').forEach(option => {
      option.addEventListener('click', () => {
        currentColor = option.dataset.color;
        $('#prop-color').value = currentColor;
        updateBrushPreview();
        
        $$('.color-option').forEach(opt => opt.classList.remove('active'));
        option.classList.add('active');
      });
    });

    // Canvas properties
    $('#prop-bgColor').addEventListener('input', e => {
      bgColor = e.target.value;
      clearCanvas();
      saveState();
    });

    $('#prop-grid').addEventListener('change', e => {
      showGrid = e.target.checked;
      clearCanvas();
    });

    // Viewport controls
    $('#clear').addEventListener('click', () => {
      if (confirm("Clear the entire canvas?")) {
        clearCanvas();
        saveState();
      }
    });
    
    $('#save').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'painting.png';
      link.href = canvas.toDataURL();
      link.click();
    });

    $('#undo').addEventListener('click', undo);
    $('#redo').addEventListener('click', redo);

    $('#new-canvas').addEventListener('click', () => {
      if (confirm("Create a new canvas? Any unsaved changes will be lost.")) {
        clearCanvas();
        canvasHistory = [];
        historyIndex = -1;
        saveState();
      }
    });

    $('#add-layer').addEventListener('click', () => {
      alert("Layer added! In a full implementation, this would create a new layer.");
    });

    // Mouse events
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);

    // Update cursor position
    canvas.addEventListener('mousemove', e => {
      const [x, y] = getMousePos(e);
      $('#cursor').textContent = `Cursor: (${Math.round(x)}, ${Math.round(y)})`;
    });

    // ---------- Animation Loop ----------
    let last = performance.now();
    function animate(now) {
      requestAnimationFrame(animate);
      const dt = (now - last) / 1000; last = now;
      
      // Update FPS counter
      $('#fps').textContent = `FPS: ${Math.round(1/Math.max(dt,1e-3))}`;
    }
    requestAnimationFrame(animate);

    // Initialize
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    updateBrushPreview();
  </script>
</body>
</html>
